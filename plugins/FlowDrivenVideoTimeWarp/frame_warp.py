# -*- coding: utf-8 -*-"""Created on Mon Oct 16 21:28:34 2017@author: KozakM"""import numpy as npimport cv2import timeclass OpticalFlow:    def __init__(self, prvs_frame, next_frame, flow):        self.prvs_frame = prvs_frame        self.next_frame = next_frame        self.flow = flow              self.hight = flow.shape[0]        self.width = flow.shape[1]                    def setFrames (self, prvs_frame, next_frame, flow):        self.prvs_frame = prvs_frame        self.next_frame = next_frame        self.flow = flow            def warpFlow(self, img, flow):        h, w = flow.shape[:2]        flow = -flow        flow[:,:,0] += np.arange(w)        flow[:,:,1] += np.arange(h)[:,np.newaxis]        res = cv2.remap(img, flow, None, cv2.INTER_LINEAR)        return res            def setTime (self, frame_time):        forward_flow = np.multiply(self.flow, frame_time)        backward_flow=np.multiply(self.flow, -(1-frame_time))        from_prev = self.warpFlow(self.prvs_frame, forward_flow)        from_next = self.warpFlow(self.next_frame, backward_flow)        #        out="D:/tmp/out-fromprev"+str(frame_time)+".png"#        cv2.imwrite(out,from_prev)#        out="D:/tmp/out-fromnext"+str(frame_time)+".png"#        cv2.imwrite(out,from_next)        from_prev = np.multiply(from_prev, (1-frame_time))        from_next = np.multiply(from_next,    frame_time)        frame = (np.add(from_prev, from_next)).astype(np.uint8)        return frame# Function to read in video frmaes and store them in an array for later use. # This limits the size of teh video to just few minutes at most. Aslo build# a concattenated histogram of the GBR of each frame. def readFrames(in_file):    cap = cv2.VideoCapture(in_file)     more_frames, frame = cap.read()    if not(more_frames):        print "Error reading input"        raise ValueError(in_file)    fps = cap.get(cv2.CAP_PROP_FPS)    frames = list()    histograms = list()    while (more_frames):         frames.append(frame)        hist=               np.asarray(np.histogram(frame[:,:,0],256,(0,255)))[0]        hist=np.append(hist,np.asarray(np.histogram(frame[:,:,1],256,(0,255)))[0])        hist=np.append(hist,np.asarray(np.histogram(frame[:,:,2],256,(0,255)))[0])        histograms.append(hist)        more_frames, frame = cap.read()    cap.release()           return [frames,histograms, fps]def createOutput(in_file):    cap = cv2.VideoCapture(in_file)     out_file = in_file+"-out.avi"#    fourcc=cv2.VideoWriter_fourcc(*'HFYU') # Huffman Lossless Codec (HFYU)    fourcc=cv2.VideoWriter_fourcc(*'MPEG')    fps    = cap.get(cv2.CAP_PROP_FPS)    height = int(np.rint(cap.get(cv2.CAP_PROP_FRAME_HEIGHT)))    width  = int(np.rint(cap.get(cv2.CAP_PROP_FRAME_WIDTH )))    out_video = cv2.VideoWriter(out_file, fourcc, fps, (width,height))     if not out_video.isOpened():        print "Error opening output"        err = (out_video + " fourcc: " + str(fourcc) +" FPS: "+ str(fps)+               " H: "+str(height)+" W: "+ str(width) )        raise ValueError(err)    cap.release()    return out_video# Function to compare frame image histograms and produce an array of the # standard deviation of the differences. # histograms: an array of concatenated GBR histograms# distance: minimum number of frames apart to start the comparison# offset: Number of frames to skip at the start of the listdef scanHistList (histograms, distance, offset):    history=np.zeros((((len(histograms)-(offset+distance))*                       (len(histograms)-(offset+distance+1))/2),                        4), np.int)    h_count=0       std_flow=0    #front frame to compare. skip the first 30    for i in range (offset, len(histograms)-distance):             for j in range (i+distance,len(histograms)-1  ):            std_flow = np.std(histograms[i]-histograms[j+1])            history[h_count,:]=[i,j, j-i,std_flow ]            h_count+=1      np.savetxt(in_file+"-histo3.csv", history, delimiter=",",fmt='%2.3f')    return history# Return the average and standard deviation for the first X number of frame # histogram differencesdef computeNormalDiffs(histograms, num_frames):    flow_list =np.zeros(num_frames)    for i in range (1,num_frames):        flow_list[i] = np.std(histograms[i]-histograms[i+1])            avg_flow = np.mean(flow_list)    sigma_flow = np.std(flow_list)    print "average flow", avg_flow, sigma_flow    return [avg_flow, sigma_flow]# return the average sigma(optical flow) def getNormalFlow (frames):    flow_list=np.zeros(len(frames)-1)    future = cv2.cvtColor(frames[0], cv2.COLOR_BGR2GRAY)    for i in range(1, len(frames)):        past = future        future = cv2.cvtColor(frames[i], cv2.COLOR_BGR2GRAY)        flow = cv2.calcOpticalFlowFarneback(past,future, None,                                            0.8, 7,  15, 3, 7, 1.5, 0)        flow_list[i-1]=np.std(flow)    print "flows";print flow_list    return np.mean(flow_list)# return the 30 best results. Needs to be updated to try to find the longest # drop that should workdef selectBestMatches(differences, sigma):    sort= differences[:,3].argsort(axis=None)    return differences[sort[:10]]#best flow defined as the lowest sigam of the optical flow between frames    def selectBestFlow( frames, best_matches):    flow_list=np.zeros(best_matches.shape[0])    for i in range (best_matches.shape[0]):        past = cv2.cvtColor(frames[best_matches[i,0]], cv2.COLOR_BGR2GRAY)        future = cv2.cvtColor(frames[best_matches[i,1]], cv2.COLOR_BGR2GRAY)        flow = cv2.calcOpticalFlowFarneback(past,future, None,                                            0.8, 7,  15, 3, 7, 1.5, 0)        flow_list[1]=np.std(flow)            return np.argmin(flow_list)# frame_a is the last frame to include before the drop# frame_b is the first frame to include afte the dropdef dropFrames (frames, a_frame, b_frame, out):    #write out video upto the drop start    print "writing video head"    for i in range (0, a_frame+1):        out.write(frames[i])            avg_flow = getNormalFlow (frames[a_frame:b_frame])           prev_frame = cv2.cvtColor(frames[a_frame], cv2.COLOR_BGR2GRAY)    next_frame = cv2.cvtColor(frames[b_frame], cv2.COLOR_BGR2GRAY)    jump_flow = cv2.calcOpticalFlowFarneback(prev_frame ,next_frame,None,                                            0.8, 7,  15, 3, 7, 1.5, 2)        std_jump_flow = np.std(jump_flow)    frames_to_add = int(np.rint(std_jump_flow / avg_flow))    print "jump, avg, frames:",std_jump_flow, avg_flow, frames_to_add    # fill in enough frames to smooth out the average flow    opticalFlow = OpticalFlow(frames[a_frame], frames[b_frame], jump_flow)    for i in range (1, frames_to_add):        frame_scale = i/(1.0*frames_to_add)        print "adding gap frame", frame_scale        frame = opticalFlow.setTime(frame_scale)        out.write(frame)             #write out the rest of the video    print"Adding tail"    for i in range (b_frame, len(frames)):        out.write(frames[i])    out.release()# in_file is the full path of the video file from which to drop frames. # the output file would will have the same basefile and placed in teh same directory# def smartDropFrames(in_file, offset_seconds, seconds_to_drop):    print "reading frames"    frames, histograms, fps =readFrames (in_file)    distance = int(round(fps*seconds_to_drop))    offset=int(round(fps*seconds_to_drop))    avg_diffs, sigma_diffs = computeNormalDiffs(histograms, 60)    print "starting histogram diffs"; t_0=time.time()    differences= scanHistList (histograms, distance, offset)    print "Finding best matches:", time.time()-t_0    best_matches = selectBestMatches (differences,sigma_diffs )    print "Starting optical flow search", sigma_diffs; print best_matches.shape[0]    if best_matches is not None:        best_flow= selectBestFlow (frames, best_matches)        print "best pair:", best_matches[best_flow]        out_video=createOutput(in_file)        dropFrames(frames, best_matches[best_flow][0],                            best_matches[best_flow][1], out_video)        out_video.release    else:        print "Can't find good frames to drop"        print "done"##############################################################################               seconds_to_drop = 2# use offset to skip the beginning of the video. Its not really frame dropping # if it starts at the very startoffset_seconds=1in_file = "D:/tmp/FD/15787326147.mov"smartDropFrames(in_file, offset_seconds, seconds_to_drop)        